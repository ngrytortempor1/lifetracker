
---

# 🧠 ローカル完結ライフログToDo — 設計まとめ

## 1. 目的と思想

> **「行動の因果関係を可視化する」ToDo＋ライフログ基盤**
> 全ての記録をローカルに保持し、データ主権と耐障害性を最優先。
> 解析やAI活用は、ユーザー端末上で行う。

---

## 2. コア設計構造

### 🔹 データモデル

すべての出来事を「イベント」として統一的に記録する。

```kotlin
@Entity(tableName = "logs")
data class LogEntity(
  @PrimaryKey val logId: String,        // UUID
  val timestampCreated: Long,
  val timestampCompleted: Long?,
  val pluginType: String,               // "todo" | "mood" | "sleep" | ...
  val taskName: String,                 // 表示名
  val tagsJson: String,                 // ["study","morning"]
  val detailsJson: String               // {slot,mood,note,...}
)
```

### 🔹 プラグイン構想

| pluginType | 内容     | 主なフィールド例                                                 |
| ---------- | ------ | -------------------------------------------------------- |
| todo       | タスク    | taskName, timestampCompleted                             |
| mood       | 朝昼夜の気分 | slot, mood(1〜5), note                                    |
| sleep      | 睡眠     | startAt, endAt, source("manual"/"usage"/"healthconnect") |

---

## 3. ログとストレージの二層構造

### ✅ SQLite（Room）

* 唯一の正（ソースオブトゥルース）
* WAL＋トランザクションで**停電・クラッシュ耐性**あり
* 書き込みは必ず`@Transaction`で完結

```kotlin
Room.databaseBuilder(context, AppDb::class.java, "life.db")
  .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
  .build()
```

### ✅ JSONL（派生レプリカ）

* 解析・バックアップ・エクスポート用
* SQLiteの`outbox`テーブルから**追記専用**で生成
* 各行にUUIDを入れて冪等性を保証

```json
{"id":"uuid","ts":1730437200000,"type":"todo_completed","body":{...}}
```

### Outboxテーブル例

```sql
CREATE TABLE outbox(
  id TEXT PRIMARY KEY,
  payload_json TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  processed_at INTEGER
);
```

### WorkManager処理フロー

1. `outbox WHERE processed_at IS NULL` を読む
2. JSONLに追記 (`append` + `\n` + fsync)
3. 書けたら `processed_at` を更新
   → 再起動後も冪等に再試行できる

---

## 4. 停電耐性と安全設計

| 対策                      | 内容                              |
| ----------------------- | ------------------------------- |
| WALモード                  | 書き途中で落ちても自動ロールバック               |
| synchronous=FULL/NORMAL | 多少遅くてもデータ整合性重視                  |
| fsyncで追記確定              | JSONLの破損を防止                     |
| 改行なし行は無視                | 落ちても削除せず再追記で修復                  |
| UUID＋冪等設計               | 重複追記しても無害                       |
| 論理削除                    | is_deleted or “delete event”で対応 |

---

## 5. 気分・睡眠ログ拡張

### ☀️ 朝昼夜の気分ログ

* スロット：`"morning" | "noon" | "night"`
* 1日3件固定でグラフ化が容易
* 時刻から自動スロット推定

```kotlin
fun currentSlot(now: LocalTime): String =
  when {
    now.isBefore(LocalTime.of(11,0)) -> "morning"
    now.isBefore(LocalTime.of(17,0)) -> "noon"
    else -> "night"
  }
```

### 🌙 睡眠ログ

3段階の精度で運用可能：

1. **手動記録**（QSタイル／ボタン）
2. **使用状況推定**（UsageStatsManager）
3. **Health Connect連携**（SleepSessionRecord）

---

## 6. グラフ可視化構想

* ノード＝イベント（task/mood/sleep…）
* エッジ＝「完了の連続」（遷移）
* エッジ重み＝遷移回数または確率
* ノード色＝カテゴリ／気分、サイズ＝頻度
* 表示例：

  * 「英単語→数学」の遷移確率70%
  * 「朝気分4」→「昼完了率80%」

---

## 7. モード方針（速度 vs 安全）

| モード           | 内容               | 想定用途             |
| ------------- | ---------------- | ---------------- |
| **安全モード**（常用） | WAL＋fsync、確実な永続化 | 通常運用（ToDo,気分,睡眠） |
| **高速モード**（レア） | fsync省略・バッチ長大    | 数万件の一括インポート時のみ   |

→ あなたの用途では**安全モード固定でOK**。
データ消失のリスク＞速度差。

---

## 8. 弱点と対策（要点）

| 弱点            | 対策                |
| ------------- | ----------------- |
| JSONL遅延整合     | Outbox空確認でエクスポート  |
| ストレージ肥大       | 日/週ごとファイル＋圧縮      |
| マイグレーション難     | JSONLに`version`付与 |
| WorkManager遅延 | 即時実行ボタンを別途用意      |
| 削除要求対応        | 論理削除＋削除イベント行      |

---

## 9. 全体フロー図（簡略）

```
[UI入力]
   ↓
[Room(DB)] ←唯一の正
   │  ↑ @Transaction
   │
[Outbox]
   ↓ (WorkManager)
[JSONL追記] → (解析/エクスポート)
```

---

## 10. 今後の拡張方向

* グラフのAI分析（遷移確率＋気分相関）
* 行動パターンから「次のおすすめ」
* ローカル生成LLM対応（自動洞察）
* Health Connect完全統合

---

## ✅ 結論

* **SQLiteを唯一の真実として保持**
* **JSONLは再生成可能な派生ログ**
* **トランザクション＋WAL＋fsyncで停電耐性**
* **削除なし・追記型・冪等設計**
* **安全モード固定で充分。高速化は不要**
* **気分・睡眠ログを統合して行動因果グラフ化**

---